#include <iostream>
using namespace std;

struct Process {
    int pid;
    int arrival;
    int burst;
    int completion;
    int turnaround;
    int waiting;
};

// Sort SJF queue by burst time
void sortByBurst(Process p[], int n) {
    for (int i = 0; i < n - 1; ++i)
        for (int j = i + 1; j < n; ++j)
            if (p[j].burst < p[i].burst)
                swap(p[i], p[j]);
}

// Sort FCFS queue by arrival time
void sortByArrival(Process p[], int n) {
    for (int i = 0; i < n - 1; ++i)
        for (int j = i + 1; j < n; ++j)
            if (p[j].arrival < p[i].arrival)
                swap(p[i], p[j]);
}

void calculateTimes(Process p[], int n, int startTime) {
    int time = startTime;
    for (int i = 0; i < n; ++i) {
        if (time < p[i].arrival) time = p[i].arrival;
        p[i].completion = time + p[i].burst;
        p[i].turnaround = p[i].completion - p[i].arrival;
        p[i].waiting = p[i].turnaround - p[i].burst;
        time = p[i].completion;
    }
}

void display(Process p[], int n, const char* label) {
    cout << "\n--- " << label << " ---\n";
    cout << "PID\tArrival\tBurst\tCompletion\tTurnaround\tWaiting\n";
    for (int i = 0; i < n; ++i)
        cout << "P" << p[i].pid << "\t" << p[i].arrival << "\t" << p[i].burst << "\t"
             << p[i].completion << "\t\t" << p[i].turnaround << "\t\t" << p[i].waiting << "\n";
}

int main() {
    int n1, n2;
    cout << "Enter number of processes in Queue 1 (SJF): ";
    cin >> n1;
    Process q1[n1];
    for (int i = 0; i < n1; ++i) {
        q1[i].pid = i + 1;
        cout << "P" << q1[i].pid << " Arrival: ";
        cin >> q1[i].arrival;
        cout << "P" << q1[i].pid << " Burst: ";
        cin >> q1[i].burst;
    }

    cout << "\nEnter number of processes in Queue 2 (FCFS): ";
    cin >> n2;
    Process q2[n2];
    for (int i = 0; i < n2; ++i) {
        q2[i].pid = n1 + i + 1;
        cout << "P" << q2[i].pid << " Arrival: ";
        cin >> q2[i].arrival;
        cout << "P" << q2[i].pid << " Burst: ";
        cin >> q2[i].burst;
    }

    // Sort and schedule Queue 1 (SJF)
    sortByBurst(q1, n1);
    calculateTimes(q1, n1, 0);
    int q1EndTime = q1[n1 - 1].completion;

    // Sort and schedule Queue 2 (FCFS)
    sortByArrival(q2, n2);
    calculateTimes(q2, n2, q1EndTime);

    // Display results
    display(q1, n1, "Queue 1 (SJF)");
    display(q2, n2, "Queue 2 (FCFS)");

    return 0;
}
